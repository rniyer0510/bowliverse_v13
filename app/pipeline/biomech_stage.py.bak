# app/pipeline/biomech_stage.py
"""
Bowliverse v13.7 — BIOMECH STAGE (Stable Option C)

This version:
- Removes all references to ctx.events.frames (deprecated)
- Uses ctx.events.release, .uah, .ffc, .bfc directly
- Adds None safety for pose frames
- Preserves the ICC continuous-flexion model from v13.7
- Ensures clean fallbacks + stable outputs
"""

import numpy as np
from typing import List

from app.pipeline.context import Context
from app.utils.angles import elbow_flexion, gaussian_smooth
from app.utils.landmarks import LandmarkMapper
from app.models.biomech_model import (
    BiomechElbowModel,
    BiomechReleaseHeightModel,
)


# -----------------------------------------------------
# Visibility confidence
# -----------------------------------------------------
def _visibility(mapper: LandmarkMapper, lm):
    if lm is None:
        return 0.0
    pts = [
        mapper.primary["shoulder"],
        mapper.primary["elbow"],
        mapper.primary["wrist"],
    ]
    vis = []
    for p in pts:
        try:
            v = lm[p].get("visibility", lm[p].get("vis", 0.0))
            vis.append(float(v))
        except Exception:
            pass
    return float(sum(vis) / len(vis)) if vis else 0.0


# -----------------------------------------------------
# MAIN
# -----------------------------------------------------
def run(ctx: Context) -> Context:
    pose_frames = ctx.pose.frames

    # Early exit: missing pose data
    if not pose_frames or len(pose_frames) < 5:
        ctx.biomech.error = "Missing pose data"
        return ctx

    events = ctx.events

    # Check event availability
    if (
        events.release is None
        or events.uah is None
        or events.release.frame is None
        or events.uah.frame is None
    ):
        ctx.biomech.error = "Missing key event frames"
        return ctx

    f_rel = int(events.release.frame)
    f_uah = int(events.uah.frame)

    if f_uah > f_rel:
        f_uah = max(0, f_rel - 3)

    # Bounds checking
    if f_rel < 0 or f_rel >= len(pose_frames):
        ctx.biomech.error = "Release frame out of range"
        return ctx
    if f_uah < 0 or f_uah >= len(pose_frames):
        ctx.biomech.error = "UAH frame out of range"
        return ctx

    mapper = LandmarkMapper(ctx.input.hand)

    # Build flexion curve between UAH → Release
    flexions: List[float] = []
    for idx in range(f_uah, f_rel + 1):
        pf = pose_frames[idx]
        lm = pf.landmarks

        if lm is None:
            # push previous value or 0
            flexions.append(flexions[-1] if flexions else 0.0)
            continue

        try:
            S = mapper._safe_vec(lm, mapper.primary["shoulder"])
            E = mapper._safe_vec(lm, mapper.primary["elbow"])
            W = mapper._safe_vec(lm, mapper.primary["wrist"])
            flex = elbow_flexion(S, E, W)
        except Exception:
            flex = flexions[-1] if flexions else 0.0

        flexions.append(float(flex))

    # Smooth curve
    flex_smooth = gaussian_smooth(flexions, sigma=1.0)

    flex_min = float(min(flex_smooth))
    flex_max = float(max(flex_smooth))
    excursion = max(0.0, flex_max - flex_min)

    uah_flex = float(flex_smooth[0])
    rel_flex = float(flex_smooth[-1])

    # Release height calculation
    pf_rel = pose_frames[f_rel]
    lm_rel = pf_rel.landmarks

    if lm_rel is None:
        ctx.biomech.error = "Missing landmarks at release frame"
        return ctx

    LS, RS = mapper.shoulders_pair(lm_rel)
    LH, RH = mapper.hips_pair(lm_rel)

    shoulder_mid = (LS + RS) / 2.0
    hip_mid = (LH + RH) / 2.0
    torso_len = abs(shoulder_mid[1] - hip_mid[1]) + 1e-6

    wrist_y = mapper._safe_vec(lm_rel, mapper.primary["wrist"])[1]
    norm_height = float((shoulder_mid[1] - wrist_y) / torso_len)

    # Confidence
    vis_rel = _visibility(mapper, lm_rel)
    vis_uah = _visibility(mapper, pose_frames[f_uah].landmarks)

    elbow_conf = int(
        50 * ((pf_rel.confidence + pose_frames[f_uah].confidence) / 2.0)
        + 50 * ((vis_rel + vis_uah) / 2.0)
    )
    elbow_conf = max(0, min(100, elbow_conf))

    release_height_conf = int(100 * pf_rel.confidence)
    release_height_conf = max(0, min(100, release_height_conf))

    # Confidence-weighted extension reduction
    extension_raw = excursion
    conf_factor = elbow_conf / 100.0

    extension_final = extension_raw
    if extension_raw > 40 and conf_factor < 0.85:
        extension_final = extension_raw * conf_factor * 0.75
    extension_final = min(extension_final, extension_raw)

    # Store in context
    ctx.biomech.elbow = BiomechElbowModel(
        uah_angle=uah_flex,
        release_angle=rel_flex,
        extension_deg=extension_final,
        extension_raw_deg=extension_raw,
        extension_error_margin_deg=6.0,
        extension_note=(
            "High confidence estimate"
            if elbow_conf > 85 else
            "Moderate confidence; minor occlusion"
            if elbow_conf > 60 else
            "Low confidence; visibility issues"
        ),
    )

    ctx.biomech.release_height = BiomechReleaseHeightModel(
        norm_height=norm_height,
        wrist_y=float(wrist_y),
    )

    ctx.biomech.elbow_conf = elbow_conf
    ctx.biomech.release_height_conf = release_height_conf
    ctx.biomech.angle_plane = {
        "uah_plane": "projected",
        "release_plane": "projected",
    }

    ctx.biomech.error = None
    return ctx

