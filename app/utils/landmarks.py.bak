import numpy as np


class LandmarkMapper:
    """
    Bowliverse v13.7 â€” Safe landmark mapper (Option A)
    All functions handle lm=None safely.
    """

    def __init__(self, hand: str, vis_threshold: float = 0.20):
        self.hand = hand.upper()
        self.vis_threshold = vis_threshold

        self.left = {
            "shoulder": 11,
            "elbow": 13,
            "wrist": 15,
            "hip": 23,
            "knee": 25,
            "ankle": 27,
            "heel": 29,
            "toe": 31,
        }

        self.right = {
            "shoulder": 12,
            "elbow": 14,
            "wrist": 16,
            "hip": 24,
            "knee": 26,
            "ankle": 28,
            "heel": 30,
            "toe": 32,
        }

        self.primary = self.right if self.hand == "R" else self.left

    # -----------------------------------------------------
    # Safe vec accessor
    # -----------------------------------------------------
    def _safe_vec(self, lm, idx, fallback=None):
        if lm is None:
            return fallback if fallback is not None else np.zeros(3)

        p = lm[idx]
        vis = float(p.get("vis", 0.0))
        if vis < self.vis_threshold and fallback is not None:
            return fallback

        return np.array([p["x"], p["y"], p["z"]], float)

    # -----------------------------------------------------
    # Arm triplet
    # -----------------------------------------------------
    def arm_triplet(self, lm, prev=None):
        if lm is None:
            return (
                prev["w"] if prev else np.zeros(3),
                prev["e"] if prev else np.zeros(3),
                prev["s"] if prev else np.zeros(3),
            )

        W = self._safe_vec(lm, self.primary["wrist"], fallback=(prev["w"] if prev else None))
        E = self._safe_vec(lm, self.primary["elbow"], fallback=(prev["e"] if prev else None))
        S = self._safe_vec(lm, self.primary["shoulder"], fallback=(prev["s"] if prev else None))
        return W, E, S

    # -----------------------------------------------------
    # Hips + shoulders
    # -----------------------------------------------------
    def hips_pair(self, lm):
        if lm is None:
            return np.zeros(3), np.zeros(3)
        LH = self._safe_vec(lm, self.left["hip"])
        RH = self._safe_vec(lm, self.right["hip"])
        return LH, RH

    def shoulders_pair(self, lm):
        if lm is None:
            return np.zeros(3), np.zeros(3)
        LS = self._safe_vec(lm, self.left["shoulder"])
        RS = self._safe_vec(lm, self.right["shoulder"])
        return LS, RS

    # -----------------------------------------------------
    # Required by events stage
    # -----------------------------------------------------
    def ankle_y(self, lm):
        if lm is None:
            return 0.0
        idx = self.primary["ankle"]
        return float(lm[idx]["y"])

    def hip_center(self, lm):
        LH, RH = self.hips_pair(lm)
        return (LH + RH) / 2.0

    # -----------------------------------------------------
    # Arm-plane normal
    # -----------------------------------------------------
    def arm_plane_normal(self, lm):
        LS, RS = self.shoulders_pair(lm)
        LH, RH = self.hips_pair(lm)

        shoulder_axis = RS - LS
        hip_axis = RH - LH
        trunk_axis = shoulder_axis + hip_axis
        trunk_axis = trunk_axis / (np.linalg.norm(trunk_axis) + 1e-9)

        global_up = np.array([0.0, 1.0, 0.0], float)
        n = np.cross(trunk_axis, global_up)
        n = n / (np.linalg.norm(n) + 1e-9)

        return n

    # -----------------------------------------------------
    # Generic accessor
    # -----------------------------------------------------
    def vec(self, lm, key: str):
        if lm is None:
            return np.zeros(3)
        idx = self.primary.get(key)
        return self._safe_vec(lm, idx)

